# 语法糖
### 数据委托

### 数据包含
我们可以给一个数据包的某个数据添加`@include`注解,那么这个数据包会拥有这个数据的所有数据:
```
Colsable[colse : ()->Unit]
File[text : Str]
    @receiver(File) colse => Unit ~
Document[
    by : Str,
    @include file : File
]
```
### 中缀函数
被标记为`@infix`的函数,只能拥有两个参数,这时候它叫中缀函数,中缀函数优先计算左边的表达式,它可以被这样调用:
```
@infix add => a:Int, b:Int > ~
@main _ =>
    print a add b
~
```
### 前缀函数
被标记为`@prefix`的函数,只能拥有一个参数,这时候它叫前缀函数,前缀函数优先计算右边的表达式,它可以被这样调用:
```
@prefix print => test:Str > ~
@main _ =>
    print "ok"
~
```
### 匿名数据
当数据只需要声明就可以起作用,并且你不在意数据的名称时,你可以使用`_`来命名数据,被命名下划线的数据无法被引用,无法被遮蔽,并且可以声明无数个.
### 隐式类型转换函数
标记`@implicit`的函数如果同时注解有`@receiver`,这个函数就叫**隐转函数**,这时候其作用域内的所有"从该隐转函数**接收者类型**到该隐转函数**返回类型**的转换都会通过调用该隐转函数来完成",注意:
+ 隐转函数可以对原来不可以隐式转换的类型生效
+ 如果作用域内有多个相同的隐转函数,那么该作用域内**无法使用/使用默认**隐式类型转换
+ 显式类型转换不会调用隐转函数
### 隐式匿名函数
```
@implicit
@receiver(Str)
_ => toInt ~
@main _ =>
    i : Int = 0
~
```
当变量或者参数类型为函数时,你可以不用写>~表示匿名函数,编译器会自动加上,但是有三个前提:
+ 被传参函数必须只有一个参数
+ 入参值不能与需求值类型相同
+ 当前作用域没有合适的隐式转换函数
```
单参数函数 => arg:()->Any > ~
@main _ =>
    单参数函数(
        print("ok1")
        print("ok2")
        print("ok3")
    )
    /*等效于
    单参数函数(>
        print("ok1")
        print("ok2")
        print("ok3")
    ~)*/
    var = print("ok")
    //等效于
    //var => print("ok") ~
~
```